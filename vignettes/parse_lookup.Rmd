---
title: "Introduction to parse() and the lookup_*() functions"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{parse}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(DOPE)
library(tidyverse)
library(stringr)
```

This package aims to parse out identifiable drug names given a corpus of text. By corpus of text, we assume that the data has already been imported into R.

## Data: drug_df
---
Throughout this vignette, we will employ a sample dataset - `drug_df` - that is intended to represent data collected from a clinical trial. The dataset contains 3 variables and 500 observations. 

```{r data, echo=TRUE}
dim(drug_df)

str(drug_df)

class(drug_df)
```
Note: `drug_df` is a simulated dataset and does not reflect any true clinical observations. 

## `parse()`
---

The `parse()` function is intended to extract identifiable drug names from a corpus of text such as, clinical trial data, social media, survey or interview transcription. `parse()` takes in one argument, the vector that contains the strings to be parsed.

Here is an example of some of problematic records in the `drug_df` dataset that warrants the use of `parse()`

```{r messy}

drug_df %>% 
  filter(str_detect(textdrug, ",|;|and|\\/|=|\\(")) %>% 
  distinct(textdrug)

```

As you can see there are so many extraneous/problematic characters, multiple drugs in one record and several variations of the same drug (i.e. "bup/nx"). We assume that the user is solely interested in the drugs themselves, not information such as dosage and units. 

This messy data is exactly what `parse()` was designed for. 

```{r}
drug_names <- parse(drug_df$textdrug)

head(drug_names)
```

The resulting vector can then be passed on to the `lookup_*` functions to identify whether the input drug is a class or category or a synonym for other drugs in the same category. 

## `lookup_*`
---

### `lookup()`

This function relies on a comprehensive lookup table `lookup_df`. This dataframe contains 3 variables:  
- `class` =  
- `category` =  
- `synonym` =  

```{r lookup_df, echo=TRUE}
dim(lookup_df)

str(lookup_df)

class(lookup_df)
```
